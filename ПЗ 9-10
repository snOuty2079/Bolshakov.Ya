def bucket_sort(arr):
    """
    Блочная сортировка - распределяет элементы по корзинам и сортирует каждую корзину отдельно
    """
    # Если массив пустой, возвращаем его
    if len(arr) == 0:
        return arr
    
    # 1. Определяем количество корзин (обычно равно количеству элементов)
    n = len(arr)
    buckets = [[] for _ in range(n)]
    
    # 2. Находим минимальное и максимальное значение для распределения
    min_val, max_val = min(arr), max(arr)
    if min_val == max_val:
        return arr
    
    # 3. Распределяем элементы по корзинам
    for num in arr:
        # Вычисляем индекс корзины для текущего элемента
        index = int((num - min_val) / (max_val - min_val) * (n - 1))
        buckets[index].append(num)
    
    # 4. Сортируем каждую корзину (используем встроенную сортировку)
    for i in range(n):
        buckets[i].sort()
    
    # 5. Объединяем отсортированные корзины
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result

# Пример использования
arr = [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
print("Исходный массив:", arr)
sorted_arr = bucket_sort(arr)
print("Отсортированный массив:", sorted_arr)
_________________________________________________________________________________________________________________________

def pancake_sort(arr):
    """
    Блинная сортировка - сортировка переворотами частей массива
    """
    n = len(arr)
    
    # Проходим по массиву с конца
    for curr_size in range(n, 1, -1):
        # 1. Находим индекс максимального элемента в неотсортированной части
        max_index = arr.index(max(arr[:curr_size]))
        
        # Если максимальный элемент не на своем месте
        if max_index != curr_size - 1:
            # 2. Переворачиваем до максимального элемента, чтобы он стал первым
            if max_index != 0:
                arr[:max_index + 1] = arr[:max_index + 1][::-1]
                print(f"Переворот до максимума: {arr}")
            
            # 3. Переворачиваем всю неотсортированную часть
            arr[:curr_size] = arr[:curr_size][::-1]
            print(f"Переворот неотсортированной части: {arr}")
    
    return arr

# Пример использования
arr = [3, 1, 4, 2, 6, 5]
print("Исходный массив:", arr)
sorted_arr = pancake_sort(arr.copy())
print("Отсортированный массив:", sorted_arr)
___________________________________________________________________________________________
def bead_sort(arr):
    """
    Сортировка бусинами - моделирует падение бусин под действием гравитации
    Работает только для неотрицательных целых чисел
    """
    # Проверяем, что все элементы неотрицательные
    if any(x < 0 for x in arr):
        raise ValueError("Сортировка бусинами работает только с неотрицательными числами")
    
    if len(arr) == 0:
        return arr
    
    # 1. Создаем "абак" - матрицу бусин
    max_val = max(arr)
    # Строки представляют числа, столбцы - разряды
    beads = [[0] * max_val for _ in range(len(arr))]
    
    # 2. Располагаем бусины на абаке
    for i in range(len(arr)):
        for j in range(arr[i]):
            beads[i][j] = 1
    
    # 3. Моделируем "падение" бусин под действием гравитации
    for j in range(max_val):
        # Считаем количество бусин в каждом столбце
        sum_beads = sum(beads[i][j] for i in range(len(arr)))
        
        # "Сбрасываем" все бусины в столбце
        for i in range(len(arr)):
            beads[i][j] = 0
        
        # Бусины оседают вниз
        for i in range(len(arr) - 1, len(arr) - sum_beads - 1, -1):
            beads[i][j] = 1
    
    # 4. Считываем результат (подсчитываем бусины в каждой строке)
    result = [sum(row) for row in beads]
    return result

# Пример использования
arr = [3, 1, 4, 1, 2]
print("Исходный массив:", arr)
sorted_arr = bead_sort(arr.copy())
print("Отсортированный массив:", sorted_arr)
______________________________________________________________________________________________________
import math

def jump_search(arr, target):
    """
    Поиск скачками - прыжки по блокам с последующим линейным поиском
    """
    n = len(arr)
    
    # 1. Определяем размер прыжка (оптимально - корень из n)
    step = int(math.sqrt(n))
    prev = 0
    
    # 2. Прыгаем по массиву, пока не найдем блок с целевым элементом
    while arr[min(step, n) - 1] < target:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n:
            return -1
    
    # 3. Выполняем линейный поиск в найденном блоке
    for i in range(prev, min(step, n)):
        if arr[i] == target:
            return i
    
    return -1

# Пример использования
arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
target = 55
print(f"Массив: {arr}")
print(f"Поиск элемента {target}")
result = jump_search(arr, target)
print(f"Элемент найден на позиции: {result}" if result != -1 else "Элемент не найден")
_____________________________________________________________________________________________________
def binary_search(arr, left, right, target):
    """Вспомогательная функция бинарного поиска"""
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def exponential_search(arr, target):
    """
    Экспоненциальный поиск - экспоненциальное расширение диапазона + бинарный поиск
    """
    n = len(arr)
    
    # Если массив пустой
    if n == 0:
        return -1
    
    # 1. Проверяем первый элемент
    if arr[0] == target:
        return 0
    
    # 2. Экспоненциально увеличиваем диапазон
    i = 1
    while i < n and arr[i] <= target:
        i *= 2
    
    # 3. Выполняем бинарный поиск в найденном диапазоне
    left = i // 2
    right = min(i, n - 1)
    return binary_search(arr, left, right, target)

# Пример использования
arr = [2, 3, 4, 10, 15, 18, 20, 22, 25, 30, 35, 40]
target = 18
print(f"Массив: {arr}")
print(f"Поиск элемента {target}")
result = exponential_search(arr, target)
print(f"Элемент найден на позиции: {result}" if result != -1 else "Элемент не найден")
______________________________________________________________________________________________________________________
def ternary_search(arr, target):
    """
    Тернарный поиск - делит массив на три части
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        # 1. Делим диапазон на три части
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        
        # 2. Проверяем граничные точки
        if arr[mid1] == target:
            return mid1
        if arr[mid2] == target:
            return mid2
        
        # 3. Определяем, в какой трети продолжать поиск
        if target < arr[mid1]:
            right = mid1 - 1
        elif target > arr[mid2]:
            left = mid2 + 1
        else:
            left = mid1 + 1
            right = mid2 - 1
    
    return -1

# Пример использования
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
target = 7
print(f"Массив: {arr}")
print(f"Поиск элемента {target}")
result = ternary_search(arr, target)
print(f"Элемент найден на позиции: {result}" if result != -1 else "Элемент не найден")
_________________________________________________________________________________________________-
