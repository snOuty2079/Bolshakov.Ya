–ü–†–ò–ú–ï–†–´ –†–ï–ê–õ–ò–ó–ê–¶–ò–ò –ê–õ–ì–û–†–ò–¢–ú–ê –ö–û–ú–ú–ò–í–û–Ø–ñ–ï–†–ê(C++).
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

class TSP {
private:
    vector<vector<int>> graph;  // –ú–∞—Ç—Ä–∏—Ü–∞ —Å–º–µ–∂–Ω–æ—Å—Ç–∏ - —Ö—Ä–∞–Ω–∏—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –≥–æ—Ä–æ–¥–∞–º–∏
    int numCities;              // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥–æ—Ä–æ–¥–æ–≤
    
public:
    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–ª–∞—Å—Å–∞
    TSP(vector<vector<int>> distances) : graph(distances) {
        numCities = distances.size();  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥–æ—Ä–æ–¥–æ–≤ –ø–æ —Ä–∞–∑–º–µ—Ä—É –º–∞—Ç—Ä–∏—Ü—ã
        cout << "–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –∑–∞–¥–∞—á–∞ –∫–æ–º–º–∏–≤–æ—è–∂–µ—Ä–∞ —Å " << numCities << " –≥–æ—Ä–æ–¥–∞–º–∏" << endl;
    }
    
    // –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏
    void solve() {
        cout << "\n=== –ù–ê–ß–ê–õ–û –†–ï–®–ï–ù–ò–Ø –ó–ê–î–ê–ß–ò –ö–û–ú–ú–ò–í–û–Ø–ñ–ï–†–ê ===" << endl;
        
        // –®–∞–≥ 1: –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≥–æ—Ä–æ–¥–æ–≤
        // –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è 4 –≥–æ—Ä–æ–¥–æ–≤: [0, 1, 2, 3]
        vector<int> cities;
        for (int i = 0; i < numCities; i++) {
            cities.push_back(i);
        }
        
        cout << "–ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≥–æ—Ä–æ–¥–æ–≤: ";
        printVector(cities);
        
        // –®–∞–≥ 2: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞
        int minDistance = INT_MAX;     // –ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ–µ —á–∏—Å–ª–æ
        vector<int> bestRoute;         // –ó–¥–µ—Å—å –±—É–¥–µ–º —Ö—Ä–∞–Ω–∏—Ç—å –ª—É—á—à–∏–π –Ω–∞–π–¥–µ–Ω–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç
        int permutationCount = 0;      // –°—á–µ—Ç—á–∏–∫ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫
        
        // –®–∞–≥ 3: –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ –º–∞—Ä—à—Ä—É—Ç–æ–≤
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º next_permutation –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫
        cout << "\n–ù–∞—á–∏–Ω–∞–µ–º –ø–µ—Ä–µ–±–æ—Ä –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤..." << endl;
        
        do {
            permutationCount++;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –¥–ª–∏–Ω—É —Ç–µ–∫—É—â–µ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞
            int currentDistance = calculateDistance(cities);
            
            // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤—ã–≤–æ–¥–∏–º –∫–∞–∂–¥—ã–π –º–∞—Ä—à—Ä—É—Ç 
            cout << "–ú–∞—Ä—à—Ä—É—Ç " << permutationCount << ": ";
            printVector(cities);
            cout << " | –î–ª–∏–Ω–∞: " << currentDistance;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –Ω–∞—à–ª–∏ –ª–∏ –º—ã –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–∏–π –º–∞—Ä—à—Ä—É—Ç
            if (currentDistance < minDistance) {
                minDistance = currentDistance;
                bestRoute = cities;
                cout << " ‚Üê –ù–û–í–´–ô –û–ü–¢–ò–ú–£–ú!";
            }
            cout << endl;
            
        } while (next_permutation(cities.begin() + 1, cities.end()));
        // –í–∞–∂–Ω–æ: –Ω–∞—á–∏–Ω–∞–µ–º –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å 1 —ç–ª–µ–º–µ–Ω—Ç–∞, —á—Ç–æ–±—ã —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –≥–æ—Ä–æ–¥ (0)
        // –≠—Ç–æ —É–º–µ–Ω—å—à–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ä–µ–±–æ—Ä–æ–≤ –≤ n —Ä–∞–∑
        
        // –®–∞–≥ 4: –í—ã–≤–æ–¥–∏–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        cout << "\n=== –†–ï–®–ï–ù–ò–ï –ù–ê–ô–î–ï–ù–û ===" << endl;
        cout << "–í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ –º–∞—Ä—à—Ä—É—Ç–æ–≤: " << permutationCount << endl;
        printSolution(bestRoute, minDistance);
    }
    
private:
    // –ú–µ—Ç–æ–¥ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –æ–±—â–µ–π –¥–ª–∏–Ω—ã –º–∞—Ä—à—Ä—É—Ç–∞
    int calculateDistance(const vector<int>& route) {
        int distance = 0;
        
        // –°—É–º–º–∏—Ä—É–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–º–∏ –≥–æ—Ä–æ–¥–∞–º–∏ –≤ –º–∞—Ä—à—Ä—É—Ç–µ
        for (int i = 0; i < route.size() - 1; i++) {
            int from = route[i];       // –¢–µ–∫—É—â–∏–π –≥–æ—Ä–æ–¥
            int to = route[i + 1];     // –°–ª–µ–¥—É—é—â–∏–π –≥–æ—Ä–æ–¥
            distance += graph[from][to]; // –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –Ω–∏–º–∏
            
            // –û—Ç–ª–∞–¥–æ—á–Ω—ã–π –≤—ã–≤–æ–¥ (–º–æ–∂–Ω–æ –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å)
            // cout << "  " << from << " ‚Üí " << to << " = " << graph[from][to] << endl;
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –Ω–∞—á–∞–ª—å–Ω—ã–π –≥–æ—Ä–æ–¥
        // –≠—Ç–æ –≤–∞–∂–Ω–æ - –º–∞—Ä—à—Ä—É—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–º–∫–Ω—É—Ç—ã–º —Ü–∏–∫–ª–æ–º
        distance += graph[route.back()][route[0]];
        
        return distance;
    }
    
    // –ú–µ—Ç–æ–¥ –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è
    void printSolution(const vector<int>& route, int distance) {
        cout << "\nüéâ –û–ü–¢–ò–ú–ê–õ–¨–ù–´–ô –ú–ê–†–®–†–£–¢ –ù–ê–ô–î–ï–ù! üéâ" << endl;
        cout << "=====================================" << endl;
        
        // –í—ã–≤–æ–¥–∏–º –º–∞—Ä—à—Ä—É—Ç –≤ –≤–∏–¥–µ —Ü–∏–∫–ª–∞
        cout << "–ú–∞—Ä—à—Ä—É—Ç: ";
        for (int i = 0; i < route.size(); i++) {
            cout << route[i];
            if (i < route.size() - 1) {
                cout << " ‚Üí ";
            }
        }
        cout << " ‚Üí " << route[0] << endl; // –ó–∞–º—ã–∫–∞–µ–º —Ü–∏–∫–ª
        
        cout << "–û–±—â–∞—è –¥–ª–∏–Ω–∞ –º–∞—Ä—à—Ä—É—Ç–∞: " << distance << " –µ–¥–∏–Ω–∏—Ü" << endl;
        
        // –í—ã–≤–æ–¥–∏–º –ø–æ–¥—Ä–æ–±–Ω—É—é —Ä–∞–∑–±–∏–≤–∫—É –º–∞—Ä—à—Ä—É—Ç–∞
        cout << "\nüìä –ü–û–î–†–û–ë–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ú–ê–†–®–†–£–¢–ï:" << endl;
        cout << "-------------------------------------" << endl;
        
        int total = 0;
        for (int i = 0; i < route.size(); i++) {
            int from = route[i];
            int to = route[(i + 1) % route.size()]; // –ò—Å–ø–æ–ª—å–∑—É–µ–º modulo –¥–ª—è –∑–∞–º—ã–∫–∞–Ω–∏—è —Ü–∏–∫–ª–∞
            int segmentDistance = graph[from][to];
            total += segmentDistance;
            
            cout << "–≠—Ç–∞–ø " << (i + 1) << ": ";
            cout << "–ì–æ—Ä–æ–¥ " << from << " ‚Üí –ì–æ—Ä–æ–¥ " << to;
            cout << " = " << segmentDistance << " –µ–¥–∏–Ω–∏—Ü";
            
            if (i == route.size() - 1) {
                cout << " (–≤–æ–∑–≤—Ä–∞—Ç –≤ –Ω–∞—á–∞–ª–æ)";
            }
            cout << endl;
        }
        
        cout << "-------------------------------------" << endl;
        cout << "–ò–¢–û–ì–û: " << total << " –µ–¥–∏–Ω–∏—Ü" << endl;
    }
    
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤–µ–∫—Ç–æ—Ä–∞
    void printVector(const vector<int>& vec) {
        cout << "[";
        for (int i = 0; i < vec.size(); i++) {
            cout << vec[i];
            if (i < vec.size() - 1) cout << ", ";
        }
        cout << "]";
    }
};

int main() {
    cout << "–ó–ê–î–ê–ß–ê –ö–û–ú–ú–ò–í–û–Ø–ñ–ï–†–ê - –ü–û–õ–ù–´–ô –ü–ï–†–ï–ë–û–†" << endl;
    cout << "=====================================" << endl;
    
    // –°–æ–∑–¥–∞–µ–º –º–∞—Ç—Ä–∏—Ü—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –º–µ–∂–¥—É –≥–æ—Ä–æ–¥–∞–º–∏
    // –ü—Ä–µ–¥—Å—Ç–∞–≤–∏–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å 4 –≥–æ—Ä–æ–¥–∞: 0, 1, 2, 3
    // –ú–∞—Ç—Ä–∏—Ü–∞ —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞ - —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç A –¥–æ B —Ä–∞–≤–Ω–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é –æ—Ç B –¥–æ A
    
    vector<vector<int>> distances = {
        // –†–∞—Å—Å—Ç–æ—è–Ω–∏—è –æ—Ç –∫–∞–∂–¥–æ–≥–æ –≥–æ—Ä–æ–¥–∞ –¥–æ –¥—Ä—É–≥–∏—Ö:
        {0,  10, 15, 20},  // –ò–∑ –≥–æ—Ä–æ–¥–∞ 0: –¥–æ 0=0, –¥–æ 1=10, –¥–æ 2=15, –¥–æ 3=20
        {10, 0,  35, 25},   // –ò–∑ –≥–æ—Ä–æ–¥–∞ 1: –¥–æ 0=10, –¥–æ 1=0, –¥–æ 2=35, –¥–æ 3=25
        {15, 35, 0,  30},   // –ò–∑ –≥–æ—Ä–æ–¥–∞ 2: –¥–æ 0=15, –¥–æ 1=35, –¥–æ 2=0, –¥–æ 3=30
        {20, 25, 30, 0}     // –ò–∑ –≥–æ—Ä–æ–¥–∞ 3: –¥–æ 0=20, –¥–æ 1=25, –¥–æ 2=30, –¥–æ 3=0
    };
    
    // –í—ã–≤–æ–¥–∏–º –º–∞—Ç—Ä–∏—Ü—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏
    cout << "\n–ú–∞—Ç—Ä–∏—Ü–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –º–µ–∂–¥—É –≥–æ—Ä–æ–¥–∞–º–∏:" << endl;
    cout << "    0   1   2   3" << endl;
    cout << "  +---------------" << endl;
    for (int i = 0; i < distances.size(); i++) {
        cout << i << " | ";
        for (int j = 0; j < distances[i].size(); j++) {
            cout << distances[i][j] << "  ";
        }
        cout << endl;
    }
    
    // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –∑–∞–¥–∞—á–∏ –∫–æ–º–º–∏–≤–æ—è–∂–µ—Ä–∞ –∏ —Ä–µ—à–∞–µ–º –µ–µ
    TSP tsp(distances);
    tsp.solve();
    
    cout << "\n=====================================" << endl;
    cout << "–†–µ—à–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!" << endl;
    
    return 0;
}
___________________________________________________________________________________________________________________________________________________________________________________
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


–ü–†–ò–ú–ï–† –ù–ê JAVA.
import java.util.*;

/**
 * –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–¥–∞—á–∏ –∫–æ–º–º–∏–≤–æ—è–∂–µ—Ä–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∂–∞–¥–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
 * (–∞–ª–≥–æ—Ä–∏—Ç–º –±–ª–∏–∂–∞–π—à–µ–≥–æ —Å–æ—Å–µ–¥–∞)
 */
public class GreedyTSP {
    
    // –ú–∞—Ç—Ä–∏—Ü–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –º–µ–∂–¥—É –≥–æ—Ä–æ–¥–∞–º–∏
    private int[][] distanceMatrix;
    private int numCities;
    private String[] cityNames; // –ù–∞–∑–≤–∞–Ω–∏—è –≥–æ—Ä–æ–¥–æ–≤ –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏
    
    public GreedyTSP(int[][] distances, String[] names) {
        this.distanceMatrix = distances;
        this.numCities = distances.length;
        this.cityNames = names;
        
        System.out.println("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –∂–∞–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è " + numCities + " –≥–æ—Ä–æ–¥–æ–≤");
        printDistanceMatrix();
    }
    
    /**
     * –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ –∂–∞–¥–Ω—ã–º –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º
     * @return —Å–ø–∏—Å–æ–∫ –≥–æ—Ä–æ–¥–æ–≤ –≤ –ø–æ—Ä—è–¥–∫–µ –ø–æ—Å–µ—â–µ–Ω–∏—è
     */
    public List<Integer> solveGreedy() {
        System.out.println("\n=== –ó–ê–ü–£–°–ö –ñ–ê–î–ù–û–ì–û –ê–õ–ì–û–†–ò–¢–ú–ê ===");
        
        // –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤
        Set<Integer> unvisited = new HashSet<>();
        for (int i = 1; i < numCities; i++) { // –ù–∞—á–∏–Ω–∞–µ–º —Å 1, —Ç–∞–∫ –∫–∞–∫ 0 - —Å—Ç–∞—Ä—Ç–æ–≤—ã–π
            unvisited.add(i);
        }
        
        // –ú–∞—Ä—à—Ä—É—Ç –∏ —Ç–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è
        List<Integer> route = new ArrayList<>();
        int currentCity = 0; // –ù–∞—á–∏–Ω–∞–µ–º —Å –ø–µ—Ä–≤–æ–≥–æ –≥–æ—Ä–æ–¥–∞
        route.add(currentCity);
        
        System.out.println("–ù–∞—á–∏–Ω–∞–µ–º —Å –≥–æ—Ä–æ–¥–∞: " + cityNames[currentCity]);
        
        // –ü–æ–∫–∞ –µ—Å—Ç—å –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω—ã–µ –≥–æ—Ä–æ–¥–∞
        while (!unvisited.isEmpty()) {
            int nearestCity = findNearestNeighbor(currentCity, unvisited);
            int distanceToNearest = distanceMatrix[currentCity][nearestCity];
            
            System.out.println("–ò–∑ " + cityNames[currentCity] + " –±–ª–∏–∂–∞–π—à–∏–π: " + 
                             cityNames[nearestCity] + " (—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: " + distanceToNearest + ")");
            
            // –ü–µ—Ä–µ–º–µ—â–∞–µ–º—Å—è –∫ –±–ª–∏–∂–∞–π—à–µ–º—É –≥–æ—Ä–æ–¥—É
            route.add(nearestCity);
            unvisited.remove(nearestCity);
            currentCity = nearestCity;
        }
        
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –Ω–∞—á–∞–ª—å–Ω—ã–π –≥–æ—Ä–æ–¥
        route.add(0);
        System.out.println("–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –Ω–∞—á–∞–ª—å–Ω—ã–π –≥–æ—Ä–æ–¥: " + cityNames[0]);
        
        return route;
    }
    
    /**
     * –ù–∞—Ö–æ–¥–∏—Ç –±–ª–∏–∂–∞–π—à–µ–≥–æ –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω–æ–≥–æ —Å–æ—Å–µ–¥–∞ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –≥–æ—Ä–æ–¥–∞
     */
    private int findNearestNeighbor(int currentCity, Set<Integer> unvisited) {
        int minDistance = Integer.MAX_VALUE;
        int nearestCity = -1;
        
        for (int city : unvisited) {
            int distance = distanceMatrix[currentCity][city];
            if (distance < minDistance) {
                minDistance = distance;
                nearestCity = city;
            }
        }
        
        return nearestCity;
    }
    
    /**
     * –í—ã—á–∏—Å–ª—è–µ—Ç –æ–±—â—É—é –¥–ª–∏–Ω—É –º–∞—Ä—à—Ä—É—Ç–∞
     */
    public int calculateTotalDistance(List<Integer> route) {
        int totalDistance = 0;
        
        for (int i = 0; i < route.size() - 1; i++) {
            int from = route.get(i);
            int to = route.get(i + 1);
            totalDistance += distanceMatrix[from][to];
        }
        
        return totalDistance;
    }
    
    /**
     * –ö—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
     */
    public void printSolution(List<Integer> route) {
        int totalDistance = calculateTotalDistance(route);
        
        System.out.println("\n –†–ï–ó–£–õ–¨–¢–ê–¢ –†–ê–ë–û–¢–´ –ñ–ê–î–ù–û–ì–û –ê–õ–ì–û–†–ò–¢–ú–ê:");
        System.out.println("=========================================");
        
        // –í—ã–≤–æ–¥–∏–º –º–∞—Ä—à—Ä—É—Ç
        System.out.print("–ú–∞—Ä—à—Ä—É—Ç: ");
        for (int i = 0; i < route.size(); i++) {
            System.out.print(cityNames[route.get(i)]);
            if (i < route.size() - 1) {
                System.out.print(" ‚Üí ");
            }
        }
        
        System.out.println("\n–û–±—â–∞—è –¥–ª–∏–Ω–∞ –º–∞—Ä—à—Ä—É—Ç–∞: " + totalDistance + " –∫–º");
        
        // –ü–æ–¥—Ä–æ–±–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ —ç—Ç–∞–ø–∞–º
        System.out.println("\n –î–ï–¢–ê–õ–ò –ú–ê–†–®–†–£–¢–ê:");
        System.out.println("-------------------");
        
        for (int i = 0; i < route.size() - 1; i++) {
            int from = route.get(i);
            int to = route.get(i + 1);
            int distance = distanceMatrix[from][to];
            
            System.out.printf("–≠—Ç–∞–ø %d: %s ‚Üí %s = %d –∫–º\n", 
                i + 1, cityNames[from], cityNames[to], distance);
        }
        
        System.out.println("-------------------");
        System.out.printf("–ò–¢–û–ì–û: %d –∫–º\n", totalDistance);
        
        // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–º —Ä–µ—à–µ–Ω–∏–µ–º (–¥–ª—è —ç—Ç–æ–≥–æ –ø—Ä–∏–º–µ—Ä–∞ –º—ã –∑–Ω–∞–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç)
        compareWithOptimal(route, totalDistance);
    }
    
    /**
     * –°—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∂–∞–¥–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–º —Ä–µ—à–µ–Ω–∏–µ–º
     */
    private void compareWithOptimal(List<Integer> greedyRoute, int greedyDistance) {
        // –î–ª—è —ç—Ç–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –≥–æ—Ä–æ–¥–æ–≤ –∏–∑–≤–µ—Å—Ç–µ–Ω –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç
        int[] optimalRoute = {0, 2, 3, 1, 0}; // –ú–æ—Å–∫–≤–∞ ‚Üí –ù–æ–≤–≥–æ—Ä–æ–¥ ‚Üí –ö–∞–∑–∞–Ω—å ‚Üí –°–ü–± ‚Üí –ú–æ—Å–∫–≤–∞
        int optimalDistance = calculateDistanceForRoute(optimalRoute);
        
        System.out.println("\n –°–†–ê–í–ù–ï–ù–ò–ï –° –û–ü–¢–ò–ú–ê–õ–¨–ù–´–ú –†–ï–®–ï–ù–ò–ï–ú:");
        System.out.println("-----------------------------------");
        System.out.println("–ñ–∞–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º: " + greedyDistance + " –∫–º");
        System.out.println("–û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç: " + optimalDistance + " –∫–º");
        
        if (greedyDistance == optimalDistance) {
            System.out.println("–ñ–∞–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –Ω–∞—à–µ–ª –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ!");
        } else {
            int difference = greedyDistance - optimalDistance;
            double percentage = ((double) difference / optimalDistance) * 100;
            System.out.printf("–ñ–∞–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª–∏–Ω–Ω–µ–µ –Ω–∞ %d –∫–º (%.1f%%)\n", 
                            difference, percentage);
        }
    }
    
    private int calculateDistanceForRoute(int[] route) {
        int distance = 0;
        for (int i = 0; i < route.length - 1; i++) {
            distance += distanceMatrix[route[i]][route[i + 1]];
        }
        return distance;
    }
    
    /**
     * –í—ã–≤–æ–¥–∏—Ç –º–∞—Ç—Ä–∏—Ü—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π
     */
    private void printDistanceMatrix() {
        System.out.println("\n–ú–∞—Ç—Ä–∏—Ü–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –º–µ–∂–¥—É –≥–æ—Ä–æ–¥–∞–º–∏ (–∫–º):");
        System.out.print("        ");
        for (String name : cityNames) {
            System.out.printf("%-8s", name);
        }
        System.out.println();
        
        for (int i = 0; i < numCities; i++) {
            System.out.printf("%-8s", cityNames[i]);
            for (int j = 0; j < numCities; j++) {
                System.out.printf("%-8d", distanceMatrix[i][j]);
            }
            System.out.println();
        }
    }
    
    /**
     * –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥: –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ —à–∞–≥–∞–º
     */
    public void demonstrateStepByStep() {
        System.out.println("\n –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –†–ê–ë–û–¢–´ –ê–õ–ì–û–†–ò–¢–ú–ê –ü–û –®–ê–ì–ê–ú:");
        System.out.println("===========================================");
        
        Set<Integer> unvisited = new HashSet<>();
        for (int i = 1; i < numCities; i++) {
            unvisited.add(i);
        }
        
        int current = 0;
        int step = 1;
        
        while (!unvisited.isEmpty()) {
            System.out.println("\n–®–∞–≥ " + step + ":");
            System.out.println("–¢–µ–∫—É—â–∏–π –≥–æ—Ä–æ–¥: " + cityNames[current]);
            System.out.println("–ù–µ–ø–æ—Å–µ—â–µ–Ω–Ω—ã–µ –≥–æ—Ä–æ–¥–∞: " + 
                unvisited.stream().map(i -> cityNames[i]).toList());
            
            // –ù–∞—Ö–æ–¥–∏–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ –≤—Å–µ—Ö –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤
            Map<Integer, Integer> distances = new HashMap<>();
            for (int city : unvisited) {
                distances.put(city, distanceMatrix[current][city]);
            }
            
            System.out.println("–†–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω—ã—Ö: " + distances);
            
            int nearest = findNearestNeighbor(current, unvisited);
            System.out.println("–í—ã–±–∏—Ä–∞–µ–º –±–ª–∏–∂–∞–π—à–∏–π: " + cityNames[nearest]);
            
            current = nearest;
            unvisited.remove(nearest);
            step++;
        }
    }
    
    // –ì–ª–∞–≤–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    public static void main(String[] args) {
        // –°–æ–∑–¥–∞–µ–º –º–∞—Ç—Ä–∏—Ü—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –º–µ–∂–¥—É —Ä–æ—Å—Å–∏–π—Å–∫–∏–º–∏ –≥–æ—Ä–æ–¥–∞–º–∏
        int[][] distances = {
            // –ú–æ—Å–∫–≤–∞, –°–ü–±, –ù–æ–≤–≥–æ—Ä–æ–¥, –ö–∞–∑–∞–Ω—å
            {0, 710,  540,  800},   // –ú–æ—Å–∫–≤–∞
            {710, 0,   220,  1500}, // –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥  
            {540, 220, 0,    1200}, // –ù–æ–≤–≥–æ—Ä–æ–¥
            {800, 1500, 1200, 0}    // –ö–∞–∑–∞–Ω—å
        };
        
        String[] cityNames = {"–ú–æ—Å–∫–≤–∞", "–°–ü–±", "–ù–æ–≤–≥–æ—Ä–æ–¥", "–ö–∞–∑–∞–Ω—å"};
        
        // –°–æ–∑–¥–∞–µ–º —Ä–µ—à–∞—Ç–µ–ª—å
        GreedyTSP solver = new GreedyTSP(distances, cityNames);
        
        // –î–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ–º –ø–æ—à–∞–≥–æ–≤—É—é —Ä–∞–±–æ—Ç—É
        solver.demonstrateStepByStep();
        
        // –†–µ—à–∞–µ–º –∑–∞–¥–∞—á—É
        List<Integer> route = solver.solveGreedy();
        
        // –í—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        solver.printSolution(route);
        
        System.out.println("\n=========================================");
        System.out.println("–ó–∞–º–µ—á–∞–Ω–∏–µ: –ñ–∞–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –Ω–µ –≤—Å–µ–≥–¥–∞ –Ω–∞—Ö–æ–¥–∏—Ç");
        System.out.println("–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ, –Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –æ—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ!";
    }
}
