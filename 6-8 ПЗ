№1
#include <iostream>
#include <vector>
using namespace std;

// Функция сортировки выбором
void selectionSort(vector<int>& arr) {
    // Проходим по всем элементам массива
    for (int i = 0; i < arr.size(); i++) {
        int minIndex = i; // Предполагаем, что текущий элемент - минимальный
        
        // Ищем минимальный элемент в неотсортированной части
        for (int j = i + 1; j < arr.size(); j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // Обновляем индекс минимального элемента
            }
        }
        
        // Меняем местами текущий элемент с найденным минимальным
        swap(arr[i], arr[minIndex]);
    }
}

int main() {
    vector<int> testArray = {64, 25, 12, 22, 11};
    cout << "Исходный массив: ";
    for (int num : testArray) {
        cout << num << " ";
    }
    
    selectionSort(testArray); // Вызов функции сортировки
    
    cout << "\nОтсортированный массив: ";
    for (int num : testArray) {
        cout << num << " ";
    }
    return 0;
}
_________________________________________________________________________________________________________________
def bubble_sort(arr):
    """
    Функция сортировки пузырьком
    Сравнивает соседние элементы и меняет их местами при необходимости
    """
    n = len(arr)
    # Внешний цикл - количество проходов по массиву
    for i in range(n):
        # Внутренний цикл - сравнение соседних элементов
        # После каждого прохода самый большой элемент "всплывает" в конец
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                # Меняем элементы местами, если они в неправильном порядке
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

def print_array(arr):
    """Вспомогательная функция для вывода массива"""
    for num in arr:
        print(num, end=" ")
    print()

if __name__ == "__main__":
    # Тестовый массив
    arr = [64, 34, 25, 12, 22, 11, 90]
    print("Исходный массив:")
    print_array(arr)
    
    bubble_sort(arr)  # Сортируем массив
    
    print("Отсортированный массив:")
    print_array(arr)
_______________________________________________________________________________________________________________________
#include <iostream>
#include <vector>
using namespace std;

// Алгоритм сортировки вставками
void insertionSort(vector<int>& array) {
    // Начинаем со второго элемента (индекс 1)
    for (int i = 1; i < array.size(); i++) {
        int key = array[i]; // Текущий элемент для вставки
        int j = i - 1;      // Индекс предыдущего элемента
        
        // Сдвигаем элементы большие key вправо
        while (j >= 0 && array[j] > key) {
            array[j + 1] = array[j]; // Сдвиг элемента
            j = j - 1;               // Переход к следующему элементу слева
        }
        // Вставляем key на правильную позицию
        array[j + 1] = key;
    }
}

// Функция для вывода массива
void printArray(const vector<int>& array) {
    for (int value : array) {
        cout << value << " ";
    }
    cout << endl;
}

int main() {
    vector<int> array = {12, 11, 13, 5, 6};
    
    cout << "Исходный массив: ";
    printArray(array);
    
    insertionSort(array); // Вызов сортировки
    
    cout << "Отсортированный массив: ";
    printArray(array);
    
    return 0;
}
_______________________________________________________________________________________________________________________________
import java.util.Arrays;

public class MergeSort {
    
    // Рекурсивная функция сортировки слиянием
    public static int[] mergeSort(int[] arr) {
        // Базовый случай: массив из 0 или 1 элемента уже отсортирован
        if (arr.length <= 1) {
            return arr;
        }
        
        // Находим середину массива
        int mid = arr.length / 2;
        // Делим массив на две части
        int[] left = Arrays.copyOfRange(arr, 0, mid);
        int[] right = Arrays.copyOfRange(arr, mid, arr.length);
        
        // Рекурсивно сортируем обе половины
        left = mergeSort(left);
        right = mergeSort(right);
        
        // Сливаем отсортированные половины
        return merge(left, right);
    }
    
    // Функция слияния двух отсортированных массивов
    private static int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0; // Индексы для left, right и result
        
        // Сравниваем элементы из обоих массивов и добавляем меньший
        while (i < left.length && j < right.length) {
            if (left[i] < right[j]) {
                result[k++] = left[i++];
            } else {
                result[k++] = right[j++];
            }
        }
        
        // Добавляем оставшиеся элементы из left (если есть)
        while (i < left.length) {
            result[k++] = left[i++];
        }
        
        // Добавляем оставшиеся элементы из right (если есть)
        while (j < right.length) {
            result[k++] = right[j++];
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10};
        System.out.println("Исходный массив: " + Arrays.toString(array));
        
        int[] sortedArray = mergeSort(array);
        System.out.println("Отсортированный массив: " + Arrays.toString(sortedArray));
    }
}
_____________________________________________________________________________________________________________________________
def shell_sort(arr):
    """
    Сортировка Шелла - улучшенная версия сортировки вставками
    Сортирует элементы на определенном расстоянии (gap)
    """
    n = len(arr)
    gap = n // 2  # Начальный шаг
    
    # Уменьшаем шаг до 1
    while gap > 0:
        # Применяем сортировку вставками для элементов на расстоянии gap
        for i in range(gap, n):
            temp = arr[i]  # Сохраняем текущий элемент
            j = i
            
            # Сдвигаем элементы, которые больше temp
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            
            # Вставляем temp на правильную позицию
            arr[j] = temp
        gap //= 2  # Уменьшаем шаг

def print_array(arr):
    """Вспомогательная функция для вывода массива"""
    for num in arr:
        print(num, end=" ")
    print()

if __name__ == "__main__":
    arr = [12, 34, 54, 2, 3]
    print("Исходный массив:", end=" ")
    print_array(arr)
    
    shell_sort(arr)  # Вызов сортировки Шелла
    
    print("Отсортированный массив:", end=" ")
    print_array(arr)
________________________________________________________________________________________________________________________
#include <iostream>
#include <vector>
using namespace std;

// Функция для вывода массива
void printArray(const vector<int>& array) {
    for (int value : array) {
        cout << value << " ";
    }
    cout << endl;
}

// Функция разделения массива относительно опорного элемента
int partition(vector<int>& array, int low, int high) {
    int pivot = array[high];  // Выбираем последний элемент как опорный
    int i = low - 1;          // Индекс меньшего элемента
    
    // Проходим по массиву и перемещаем элементы меньшие pivot
    for (int j = low; j < high; j++) {
        if (array[j] <= pivot) {
            i++;
            swap(array[i], array[j]); // Меняем местами
        }
    }
    
    // Помещаем опорный элемент на правильную позицию
    swap(array[i + 1], array[high]);
    return i + 1; // Возвращаем индекс опорного элемента
}

// Основная функция быстрой сортировки
void quickSort(vector<int>& array, int low, int high) {
    if (low < high) {
        // Получаем индекс разбиения
        int pi = partition(array, low, high);
        
        // Рекурсивно сортируем элементы до и после разбиения
        quickSort(array, low, pi - 1);
        quickSort(array, pi + 1, high);
    }
}

int main() {
    vector<int> array = {10, 7, 8, 9, 1, 5};
    
    cout << "Исходный массив: ";
    printArray(array);
    
    quickSort(array, 0, array.size() - 1); // Запуск сортировки
    
    cout << "Отсортированный массив: ";
    printArray(array);
    
    return 0;
}
_______________________________________________________________________________________________________________________________________
public class HeapSort {
    
    // Функция для поддержки свойства кучи (max-heap)
    public static void heapify(int[] arr, int n, int i) {
        int largest = i;        // Инициализируем корень как наибольший элемент
        int left = 2 * i + 1;   // Левый потомок
        int right = 2 * i + 2;  // Правый потомок
        
        // Если левый потомок больше корня
        if (left < n && arr[i] < arr[left]) {
            largest = left;
        }
        
        // Если правый потомок больше наибольшего элемента
        if (right < n && arr[largest] < arr[right]) {
            largest = right;
        }
        
        // Если наибольший элемент не корень
        if (largest != i) {
            // Меняем местами корень с наибольшим элементом
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            
            // Рекурсивно heapify затронутое поддерево
            heapify(arr, n, largest);
        }
    }
    
    // Основная функция пирамидальной сортировки
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // Построение max-heap (перегруппировка массива)
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Один за другим извлекаем элементы из кучи
        for (int i = n - 1; i > 0; i--) {
            // Перемещаем текущий корень в конец
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            
            // Вызываем heapify на уменьшенной куче
            heapify(arr, i, 0);
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.print("Исходный массив: ");
        for (int num : arr) {
            System.out.print(num + " ");
        }
        
        heapSort(arr); // Сортируем массив
        
        System.out.print("\nОтсортированный массив: ");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
________________________________________________________________________________________________________
def linear_search(arr, target):
    """
    Линейный поиск - простейший алгоритм поиска
    Проверяет каждый элемент последовательно
    """
    # Проходим по всем элементам массива
    for i in range(len(arr)):
        # Если нашли искомый элемент
        if arr[i] == target:
            return i  # Возвращаем индекс элемента
    return -1  # Элемент не найден

if __name__ == "__main__":
    # Тестовые данные
    array = [3, 5, 2, 7, 9, 1, 4]
    target = 7
    
    # Выполняем поиск
    result = linear_search(array, target)
    
    # Выводим результат
    if result != -1:
        print(f"Элемент найден на позиции: {result}")
    else:
        print("Элемент не найден")
_________________________________________________________________________________________________________________________
#include <iostream>
#include <vector>
using namespace std;

// Функция бинарного поиска (только для отсортированных массивов)
int binarySearch(const vector<int>& array, int target) {
    int left = 0;                    // Левая граница поиска
    int right = array.size() - 1;    // Правая граница поиска
    
    // Пока границы не пересеклись
    while (left <= right) {
        // Находим середину (защита от переполнения)
        int mid = left + (right - left) / 2;
        
        // Если нашли элемент
        if (array[mid] == target) {
            return mid; // Возвращаем индекс
        }
        
        // Если искомый элемент меньше среднего
        if (array[mid] > target) {
            right = mid - 1; // Сужаем поиск к левой половине
        } else {
            left = mid + 1;  // Сужаем поиск к правой половине
        }
    }
    return -1; // Элемент не найден
}

int main() {
    // Отсортированный массив (обязательное условие!)
    vector<int> sortedArray = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    int target = 7;
    
    // Выполняем бинарный поиск
    int result = binarySearch(sortedArray, target);
    
    // Выводим результат
    if (result != -1) {
        cout << "Элемент найден на позиции: " << result << endl;
    } else {
        cout << "Элемент не найден" << endl;
    }
    
    return 0;
}
_________________________________________________________________________________________________________
public class InterpolationSearch {
    
    // Рекурсивный интерполяционный поиск
    public static int interpolationSearch(int[] arr, int lo, int hi, int x) {
        // Проверяем границы и что x в пределах массива
        if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {
            // Вычисляем предполагаемую позицию по формуле интерполяции
            int pos = lo + (((hi - lo) * (x - arr[lo])) / (arr[hi] - arr[lo]));
            
            // Если элемент найден
            if (arr[pos] == x) {
                return pos;
            }
            
            // Если x больше, ищем в правой части
            if (arr[pos] < x) {
                return interpolationSearch(arr, pos + 1, hi, x);
            }
            
            // Если x меньше, ищем в левой части
            if (arr[pos] > x) {
                return interpolationSearch(arr, lo, pos - 1, x);
            }
        }
        return -1; // Элемент не найден
    }
    
    public static void main(String[] args) {
        // Отсортированный массив с равномерным распределением
        int[] arr = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
        int x = 18;
        
        // Выполняем интерполяционный поиск
        int result = interpolationSearch(arr, 0, arr.length - 1, x);
        
        if (result != -1) {
            System.out.println("Элемент найден на позиции: " + result);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
____________________________________________________________________________________________________________
def fibonacci_search(arr, x):
    """
    Поиск Фибоначчи - алгоритм поиска с использованием чисел Фибоначчи
    Эффективен для больших массивов
    """
    n = len(arr)
    
    # Инициализация чисел Фибоначчи
    fib_m2 = 0  # F(m-2)
    fib_m1 = 1  # F(m-1)
    fib_m = fib_m2 + fib_m1  # F(m)
    
    # Находим наименьшее число Фибоначчи, большее или равное n
    while fib_m < n:
        fib_m2 = fib_m1
        fib_m1 = fib_m
        fib_m = fib_m2 + fib_m1
    
    offset = -1  # Смещение для исключенного диапазона
    
    # Пока есть элементы для проверки
    while fib_m > 1:
        # Проверяем элемент на позиции i
        i = min(offset + fib_m2, n - 1)
        
        if arr[i] < x:
            # Переходим к правому подмассиву
            fib_m = fib_m1
            fib_m1 = fib_m2
            fib_m2 = fib_m - fib_m1
            offset = i
        elif arr[i] > x:
            # Переходим к левому подмассиву
            fib_m = fib_m2
            fib_m1 = fib_m1 - fib_m2
            fib_m2 = fib_m - fib_m1
        else:
            return i  # Элемент найден
    
    # Проверяем последний элемент
    if fib_m1 and offset + 1 < n and arr[offset + 1] == x:
        return offset + 1
    
    return -1  # Элемент не найден

if __name__ == "__main__":
    arr = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
    x = 85
    
    result = fibonacci_search(arr, x)
    
    if result != -1:
        print(f"Элемент найден на позиции: {result}")
    else:
        print("Элемент не найден")
_______________________________________________________________________________________________________________-
